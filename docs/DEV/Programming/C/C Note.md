TIOBE编程语言热度榜：[TIOBE Index - TIOBE](https://www.tiobe.com/tiobe-index/)
## 计算机基础
程序的执行
	解释
	编译
告诉计算机干什么：编程语言
与计算机交谈：命令行
计算的步骤：算法
让计算机做的事情：计算

## C基础
C用处
![[3dca061603787922fd9bc30fdb49976.jpg]]
底层（服务器、操作系统）：C
前端（网站前端）：其他语言

IDE 编辑器
![[000ce460c108f6d8b4f9dab9555d2a1.jpg]]
# Chap 1 & Chap 6 数据类型、运算符、表达式
## 数据存储
bit位数：0 ~ 长度-1 位
符号位：最高位（第长度-1位）
## 数据类型

![[301ec81126e29fadd867816f3351df2.jpg]]

### 变量和常量
一、变量
作用：放数据的地方
定义：
	C89：变量必须在程序一开始全部定义
	C99：任何位置都可以定义变量
名字：标识符
	规则字母数字下划线组成；数字不能是第一个字符；不能是关键字
赋值：
	定义时赋值：初始化，C的初始化和赋值差异不大
	$a = b$：b给a
	所有变量作右值前都得进行赋值，否则随机值

二、常量
常量的定义方法
	1. `const`关键字（声明只读变量）
		可以全局变量可以局部变量
		举例：
		`const double PI = 3.1415;`
		`const int MAX = 100;`
	2. `#define`
		`#define PI 3.1415`
		`#define MAX 100`
		其实是[[C Programming Note|宏]]
### 基本数据类型
#### 整型
概念
	整型和整型常量
		整型常量 == 整数
		unsigned : 没有符号位，所有位都用于表示数值
		理解：
			就是数字
			5就一直是5，而x可以是5，也可以是19
			你自己会做判断 x == 5，那么5就是整型常量
存储
	int 4byte = 32bit
	想让计算机用特定byte存储数字：加后缀
	eg：`123L`,`123UL`, `123UL`
	三种码：
		补码：使得数据的表示唯一：主要是0和-0统一
		补码：减法用加法做   <font color="#7030a0">问</font>
		溢出：会有进位，溢出最高位舍
		”指令“（Chap 1)  <font color="#7030a0">看书</font>
		原码：0 和 -0 表示不一样
		正数的三个码相同：符号位0，其余为二进制
		负数：
			原码：符号位1，其他位与为绝对值的二进制
			反码：符号位1，除符号位其他为原码的反
			补码：反码+1
		补码的补码是原码，用于判断数字是多少（知道了原码才能判断）
	内存中按补码存储： 
```c
int a = -1;
printf("%d, %u", a, a);
//结果：-1, 4294967295
printf("%o, %x", a, a);
//结果：37777777777, ffffffff
```


输入输出
	格式控制说明符
	![[49463e952ef88e78e620d823dea87ba.jpg]]
	![[2d31455118c75282fc1fa4de5ea3b70.jpg]]
	原因：
		十进制（Decimal）
		八进制（Octal）
		十六进制（Hexadecimal）
	整数实数：`scanf, printf`
	scanf：以行为单位，按下回车前不会读到任何东西
	进制：16：X对应A~F； x对应a~f
```c
//进制转换
printf("%d, %o, %x", 10, 10, 10);
printf("%d, %d, %d", 10, 010, 0x10);
```

#### 实型/浮点型
 概念
	表示形式：小数/科学计数法
	数据精度 与 取值范围是两个不同的概念：
	float x = 1234567.89;   x虽在取值范围内，但无法精确表达。 
	float y = 1.2e55;   y 的精度要求不高，但超出取值范围。
	double ： 实型常量的类型都是double : 写一个带小数点的数字面量都是double
	float ：得说明，eg: 
```c
float a, b;
a = 1.234f;
b = 2.345F;
```
	
<details>
<summary>点击查看科学计数法的规则</summary>

2. **表示形式**：在C语言中，科学计数法的表示形式为 `aExn` 或 `aE-n`，其中：
   - `a` 是一个实数（可以是小数或整数）。
   - `E` 或 `e` 是一个字符，用于表示指数部分的开始。
   - `n` 是一个整数，表示10的指数。

3. **实数部分**：
   - `a` 可以是任何合法的浮点数，包括小数点和小数点后的数字。
   - `a` 可以是一个整数，后面跟着一个小数点（例如 `1.`）。
   - `a` 也可以是一个小数，后面跟着一个整数（例如 `.5`）。

4. **指数部分**：
   - `n` 可以是任何整数，包括正数、负数或零。
   - 如果 `n` 是正数，表示 `a` 乘以10的正数次幂。
   - 如果 `n` 是负数，表示 `a` 乘以10的负数次幂。

5. **有效数字**：`a` 中的有效数字数量决定了数值的精度。

6. **范围**：指数 `n` 的值必须在浮点数类型的表示范围内，否则可能会导致溢出或下溢。

7. **示例**：
   - `1.23E4` 表示 `1.23 * 10^4` 或 `12300`。
   - `5.0E-2` 表示 `5.0 * 10^-2` 或 `0.05`。

8. **精度**：在C语言中，浮点数的精度受到所使用的浮点数类型（如 `float`、`double` 或 `long double`）的限制。


在C语言中，实数（浮点数）在内存中的存储并不是使用补码形式，而是遵循IEEE 754标准。这个标准定义了浮点数在计算机中的存储方式，包括单精度（32位）和双精度（64位）浮点数的格式。
```c
int number = 10;
printf("%e\n", number); // 输出 1.000000e+01
```
</details>

| 类型         | float                  | double                   |
| ---------- | ---------------------- | ------------------------ |
| 存储         | 4byte = 32bit          | 8byte = 64bit            |
| 数据精度（有效数字） | 7~8位                   | 15~16位                   |
| 取值范围       | $10^{-38}$ ~ $10^{38}$ | $10^{-308}$ ~ $10^{308}$ |
存储
<details>
<summary> 点击查看实数的存储 IEEE 754标准 </summary>
IEEE 754标准将浮点数分为三个部分：

1. **符号位（Sign bit）**：1位，用于表示数值的正负，0表示正数，1表示负数。

2. **指数位（Exponent）**：用于存储指数部分，单精度为8位，双精度为11位。指数部分采用偏移量（bias）表示，单精度的偏移量为127，双精度的偏移量为1023。

3. **尾数位（Mantissa，也称为有效数字或 significand）**：用于存储有效数字部分，单精度为23位，双精度为52位。尾数部分通常不包括最高位的1（隐含的前导1），除了特殊情况。

存储格式

以双精度浮点数（64位）为例，其存储格式如下：

- **1位符号位**：最高位，0表示正数，1表示负数。
- **11位指数**：接下来的11位，用于存储指数的偏移量。
- **52位尾数**：剩余的52位，用于存储有效数字。

举例

假设有一个双精度浮点数 `3.14`，其二进制表示为 `1.1001000110100010100011110100110110`（不包括隐含的前导1），则其在内存中的存储方式如下：

1. **符号位**：0（因为3.14是正数）
2. **指数**：计算指数部分，3.14的二进制科学计数法为 `1.1001000110100010100011110100110110 * 2^1`，指数为1，加上偏移量1023，得到1024，二进制为 `10000000000`。
3. **尾数**：`1001000110100010100011110100110110`（不包括隐含的前导1）

因此，3.14在内存中的存储为：

```
0 10000000000 1001000110100010100011110100110110
```

总结

C语言中的实数（浮点数）在内存中以IEEE 754标准的形式存储，而不是补码形式。这种存储方式允许高效地表示和处理浮点数，包括正负数、零、非规格化数（接近于零的数）和特殊值（如无穷大和NaN）。
</details>
	float 4byte = 32bit
	double 8byte = 64bit
	符号位 + 阶码 + 尾数
	不能精确存储！
	eg：
```c
printf("%d", 2.1 - 1 == 0.1);  //输出：0
printf("%d", 0.1 == 0.1);  //输出：1（非零）
```
```c
//判断俩实数是否相等
/*
wrong:
if(f1 == f2){}
*/
fabs(f1 - f2) < 1e-12  //其实1e-8就够了
```

#### 字符型
概念
	字符型和字符型常量
		字符型常量：单个字符
		理解：
			`char ch = 'a'`
			/ * ch : 字符型变量；'a' : 字符型常量 * /

存储
	字符型数据
		char 1byte = 8bit
		存ASCII
<details>
<summary>点击查看转义字符 by Kimi</summary>
转义字符（Escape Character）在编程语言中，特别是在C语言中，是一种特殊的字符序列，它以反斜杠（\）开始，后跟一个或多个字符，用来表示一个非打印的控制字符、一个特殊字符或者一个转义序列。转义字符的主要目的是允许程序员在字符串中包含那些通常不能直接通过键盘输入或者在字符串中具有特殊含义的字符。

字符常量，代表一个字符
  '\n'   '\101'   '\x41'   'A'

定义的组成部分：

1. **反斜杠（\）**：
   - 反斜杠是转义字符的开始标志，它告诉编译器后面的字符是特殊的，不应该按照字面意思来解释。

2. **跟随字符**：
   - 紧跟在反斜杠后面的字符或字符序列，它们共同构成了转义字符的完整定义。这些跟随字符定义了转义序列的具体含义。

分类：

1. **控制字符**：
   - 如换行符（\n）、回车符（\r）、制表符（\t）等，它们用于控制文本的显示或设备的控制，而不是用来显示字符本身。

2. **特殊字符**：
   - 如单引号（\'）、双引号（\"）、反斜杠（\\）等，它们用于在字符串中包含那些在普通字符串字面量中具有特殊含义的字符。

3. **八进制和十六进制转义序列**：
   - 八进制转义序列（如\101）和十六进制转义序列（如\x41）用于表示特定的ASCII字符，它们允许程序员以数值形式指定字符。

4. **通用转义序列**：
   - 以单个数字（0-9）或多个数字（最多三位八进制数）开头的转义序列，用于表示特定的控制字符。

作用：

- **表示不可打印字符**：转义字符允许程序员在字符串中包含那些在控制台上不可打印的字符，如换行符和制表符。
- **包含特殊字符**：在字符串中包含那些通常被解释为字符串结束标志或具有特殊含义的字符，如单引号和双引号。
- **跨平台兼容性**：转义字符提供了一种跨平台的方式来表示特殊字符，使得代码可以在不同的操作系统和环境中保持一致的行为。
- **文本格式化**：转义字符常用于格式化输出，如创建多行字符串或调整文本的对齐。

应用：

1. **多行字符串**：
   ```c
   printf("Line 1 \
   Line 2");
   ```
   这个例子中，反斜杠 `\` 用于将字符串字面量分割成多行，以提高代码的可读性。输出结果将是：
   ```
   Line 1 Line 2
   ```

2. **包含特殊字符的字符串**：
   ```c
   char str[] = "He said, \"Hello, World!\"";
   ```
   这里，`\"` 用于在字符串中包含双引号，这样字符串就可以被正确地打印出来，包含引号。输出结果将是：
   ```
   He said, "Hello, World!"
   ```

3. **使用八进制和十六进制转义序列**：
   ```c
   printf("ASCII: \101 \102 \103\n"); // 八进制表示
   printf("ASCII: \x41 \x42 \x43\n"); // 十六进制表示
   ```
   这里，`\101`、`\102`、`\103` 分别是字母 `A`、`B`、`C` 的八进制ASCII码，而 `\x41`、`\x42`、`\x43` 分别是 `A`、`B`、`C` 的十六进制ASCII码。输出结果将是：
   ```
   ASCII: A B C
   ASCII: A B C
   ```

4. **使用退格符**：
   ```c
   printf("Type \bnot\b me\n");
   ```
   这里，`\b` 是退格符，用于删除前一个字符。输出结果将是：
   ```
   Type  me
   ```

5. **使用空字符**：
   ```c
   char str[] = "Hello\0World";
   printf("%s\n", str);
   ```
   这里，`\0` 是空字符，它将字符串在 `Hello` 后面截断，所以 `World` 不会被打印出来。输出结果将是：
   ```
   Hello
   ```

6. **使用回车符和换行符**：
   ```c
   printf("First line.\rSecond line.\n");
   ```
   这里，`\r` 是回车符，将光标移动到行首，然后打印 `Second line.`，覆盖了 `First line.`。输出结果将是：
   ```
   Second line.
   ```
</details>
	所有字符都可以用转义字符表示
	eg：打印`A`
   ```c
   printf("%c\n", 'A'); //直接
   ```
   ```c
   printf("%c\n", 65); //ASCII
   ```
   ```c
   printf("%c\n", '\x41'); //使用转义序列`\x`后跟十六进制的ASCII码值打印`A`（在支持C99标准或更高版本的编译器中）
   ```
   ```c
   printf("%c\n", '\101'); //八进制的ASCII码
   ```

#### 关系
整型变量和字符型变量的定义和值都可以交换

#### 类型转换

^a5d957

零、情况
1. 不同类型数据的混合运算
2. 整型数据除法需要得到小数
一、自动
（一）、非赋值运算
1. 理论
	![[Pasted image 20241104195651.png]]
	水平方向：自动
	垂直方向：低 —>高 

（二）、赋值运算
1. 理论
	![[Pasted image 20241104195939.png]]
	例子：
	```c
short bi;
bi = 0x12345678L; //长整型十六进制
printf("%d", bi);
/*
warning: overflow in conversion from ‘long int’ to ‘short int’ changes value from ‘305419896’ to ‘22136’ [-Woverflow]
   11 | bi = 0x12345678L;
      |      ^~~~~~~~~~~
*/
```
	数值溢出时：
		 **截断**：由于数值超出了 `short` 类型的范围，编译器会将这个数值截断到 `short` 类型能表示的范围。具体来说，它会取这个数值的低16位。`0x12345678L` 的二进制表示是 `0001 0010 0011 0100 0101 0110 0111 1000`，取低16位是 `0101 0110 0111 1000`，即 `0x5EF8`。

二、强制类型转换
	方法：(类型名)  表达式
	例子：
	![[Pasted image 20241104200854.png]]
	后两个：看优先级：（）比（类型名）高
	![[Pasted image 20241104200907.png]]
三、举例
利用字符运算
eg：0~9出现的次数：
getchar输入，count\[char - '0'] ++
### 杂项
- static & auto
	C语言有很多区放变量：常量区、静态区、栈区、堆区
	动态变量 auto
		特点：调用一次分配一次内存，调用结束就释放了，重来
		定义：在C语言中，`auto` 关键字用于声明自动存储期的局部变量。它告诉编译器，该变量应该在栈上分配，并且其生命周期仅限于声明它的函数或代码块。然而，`auto` 关键字实际上是可选的，因为在函数内部声明的变量默认就是自动存储期的。
		在C99标准之前，`auto` 关键字是必需的，但在C99及以后的标准中，它变得可选。
	静态变量 static
		特点：整个程序运行期间存在，等程序结束后释放
	全局静态变量
		作用：只可以使其在声明的文件中可见，避免与其他文件中同名变量冲突
	静态函数 ```static int function_name(parameter_type parameter)```
		作用：只能在所声明的文件中调用，其他文件不可使用：辅助函数、实用函数限制在特定文件中
   局部静态变量
		定义：函数内部定义的静态变量
		作用：类似全局变量，函数调用结束后，其值不会被销毁，而是保持存在
		用处：重复使用，这一次的接着上一次的值用
		例子：
```c
#include<stdio.h>
//三个变量都赋初始值0
int global = 0;  //global为全局变量
void stc()
{
    int n = 0;  //n 为局部变量
    static int sta = 0;  //sta为静态局部变量
    n++; sta++; global++;  //函数每次执行都对三个变量+1
    printf("%d ", n); printf("%d ", sta); printf("%d ", global);
}
int main()
{
    int i;
    for(i = 1; i <= 5; i++){
        stc(); printf("\n");  //三次调用函数
    }
    return 0; 
}
/* 输出：
1 1 1 
1 2 2 
1 3 3 
1 4 4 
1 5 5 
全局变量和静态局部变量都延续了上次调用的结果继续+，局部变量从初始值开始
*/
```

- ASCII
	单个数字0(0)（ASCII的0位）就是'\0'
	带引号的字符0('0') 是ASCII的48位
	![[6db4cca54a511dbf742bdd7cf61ed65.jpg]]![[54e7a2f196162244e757db8e4419be3.jpg]]


## 运算符和表达式
定义：运算符 + 运算对象
	运算符：具有运算功能的符号
	运算对象：常量、变量和函数等表达式
分类
	算术表达式、赋值表达式、关系表达式、逻辑表达式、条件表达式和逗号表达式 
注意：表达式也有值！
### 优先级
<font color="#ff0000">最好都加上逗号</font>

![[a08a86aa439b597a9138fdbb9c74764.jpg]]
![[7ef019041476669ffd8f986f4a75597.jpg]]

逗号表达式：PPT

逻辑表达式：C赋值：真1 假0
循环判断：非零真

补充：
++ --
数据的值一样
<font color="#245bdb">表达式的值</font>不一样
	a++：表达式：a+1之前的值，把表达式的值赋给其他
	++a：表达式：a+1之后的值，把表达式的值赋给其他
只能对变量不能对表达式

左右结合？？？先从哪边算

x = y = 3 : 不能在变量定义处用，可以后面用，结合顺序
复合赋值：i+=1：更高效
<font color="#ff0000">看PPT！！！</font>

逻辑运算
短路：
||：前面真后面不算
&&：前面假后面不算

短路+结合方向先算谁？？

### 位运算
不改变x本身，拿到的是表达式的值
~x：按位取反
正整数：左移一位\*2；整数不是


# 循环和分支

循环：for while 
写无限循环遇到某条件跳出：
```c
for(i = 0; ; i++){
if(/*条件*/) break;
else /*代码块例如cnt++*/;
}
```
```c
while(1){
/*代码块例如cnt++*/;
if(/*条件*/) break;
}
```
<details>
<summary> hide </summary>
1. **字符串拷贝**：`strcpy(s1, s2)` 将字符串 `s2` 拷贝到 `s1` 中。
```c
   char s1[20], s2[] = "Hello";
   strcpy(s1, s2);
```


</details>
# Chap 5_Function

## 定义、声明与调用
### 声明
编译器一行一行编译，故调用之前应该让编译器知道函数的返回类型、参数、名称
所以：定义放前面or定义放后面 + 前面声明
最好用声明：一上来先看明白main函数干什么
位置
	书上：写在main里面
	现在：写在main前面
规范
	定义声明一致
		实际上，声明中可以只写变量类型，也可以变量名称和函数定义头部不一样。因为编译器检查只检查定义和声明变量类型是否一样
### 参数和值
函数的参数
	**核心：要在函数内部对主函数的变量进行操作，则必须得把主函数中的那个变量or其地址传入函数**
形参实参
	函数定义时头部的：形参
	调用函数时传进来的参数：实参
	PS：wk说就记住参数和值的关系：实参——参数；形参——值（参数的值）：就是传值
定义与调用
	定义时/调用时：函数名后面的( )必须有，不管有没有参数

数组作为函数的参数
	void func(int arr\[]) { }
	void func(int arr\[a_certain_number]) { }
	void func(int arr\[], int size) { }
	void func(int \*arr) { }
	void func(int \*arr, int size) { }
	void func(void \*arr) {int \*intArr = (int \*)arr; //函数体内部进行类型转换 }

### 变量空间：
每个函数都有他自己的变量空间；
离开一个函数f到另一个函数g里面，则会跳出f的变量空间，来到g的变量空间；
在一个函数g里面对变量操作，不会影响f里面的变量，因为不在一个变量空间；
见下视频
### 局部变量
前置
	生存期：变量多会出现，多会消亡
	作用域：在代码的什么范围内可以访问这个变量（这个变量起作用）
局部变量(\==本地变量、自动变量)
	概念：每次函数运行，都产生一个独立的变量空间，这个空间中的变量是函数这次运行独有的
	分类：定义在函数内部 + 参数
	规则
		定义在块内
			函数的块内
			语句的块内
			甚至以单拉一个大括号定义变量
		进入块，变量存在；离开块，变量消失（即生存期作用域都在大括号内，即“块”内）
		内部的变量外部不可以访问，外部的变量内部可以访问
		同名变量：
			内外同名：内部掩盖外部的
			内部同名：编译错误redefination
		本地变量不会默认初始化，但是参数进入函数时已经被初始化（参数的传递）
		![[55a7b8c90efe878d4ecf269b11cb28c.png]]
		![[1ae63b1b822794349f18894e4a76d7fe.mp4]]
	![[dba5e536d2c30866c045c8752b9a64a3.mp4]]![[c729e7b6dfd19a77f9625d1be1098c4a 1.mp4]]
### 调用函数
传递的值（实参）：常量、变量、表达式（的值）
类型不匹配：
	会发生自动类型转换：即将传入的参数类型转换为定义中说的那个类型
		PS:[[C Programming Note#^a5d957|复习一下类型转换]]
	Java C++会严格检查类型的匹配
传值
	C语言调用函数，永远是传值给函数，跟变量名啥的没关系
	即参数传递的单向性：实参的值传给形参，形参的值改变了，也不会影响实参
	其实还是变量空间的问题
	![[4e527204c0c01a9ff4e504ef279b0fa.jpg]]
### 返回值
return的作用：
	1. 结束执行函数，
	2. 返回一个值，将这个值给到调用它的地方：*调用它的地方那里写的函数调用就是代表该函数的返回值*
写法：
	1. `return;`, 
	2. `return 表达式;` ps：写法2就是表达式，单个变量也是表达式，就是将表达式的值传出去
多出口与单一出口
	函数里面可以多个return，也可以不在函数最后。
	*单一出口理念*：最好函数只有一个出口即只有一个return。
结果：
	可以丢弃，要函数执行过程中的其他东西，丢弃返回值
void无返回值
	不能用带值的return，调用时不能做返回值的赋值
	可以没有return

### 杂项
- 没有参数
	f(void) : 不传参数
	f( ) : 声明时别这样写
- 逗号运算符
	f(a, b) : 逗号是标点符号不是运算符，这是传了俩参数
	f((a, b)) : (a, b)是一个表达式，值是b，则这句代表传的是这个表达式的值：b（一个值）
- 函数中不能定义函数，可以声明
- 函数声明可以放在自己的定义里面
- main函数
	return 0; 有意义: 返回0：正确；返回非0：异常
		win：P处理文件（执行程序 + `if errorlevel 1 ...`，BAT文件，
		Unix bash : `echo $?`: 可查看main的返回值（return -1 ：看到的是255）

## 标准库


<details>
<summary> 点击查看常见标准库中的常见函数</summary>
C语言的标准库（Standard Library）是一组预定义的函数，它们提供了基本的输入输出、数学计算、字符串处理、内存分配、文件操作等功能。这些库函数使得程序员能够高效地实现常见的编程任务，而不需要从头开始编写代码。以下是一些主要的C语言标准库及其功能：

1. **标准输入输出库（stdio.h）**：
   - 提供了基本的输入输出功能，如 `printf()`、`scanf()`、`getchar()`、`putchar()`、`fgets()`、`fputs()` 等。

2. **标准数学库（math.h）**：
   - 提供了各种数学函数，如三角函数、指数函数、对数函数、幂函数等，例如 `sin()`、`cos()`、`log()`、`pow()`。

3. **字符串处理库（string.h）**：
   - 提供了字符串操作函数，如 `strcpy()`、`strcat()`、`strlen()`、`strcmp()`、`strchr()`、`strstr()` 等。

4. **动态内存分配库（stdlib.h）**：
   - 提供了动态内存分配和释放的函数，如 `malloc()`、`calloc()`、`realloc()`、`free()`，以及类型转换函数 `atoi()`、`atof()`、`atol()` 等。

5. **字符处理库（ctype.h）**：
   - 提供了字符分类和转换函数，如 `isalpha()`、`isdigit()`、`tolower()`、`toupper()` 等。

6. **时间处理库（time.h）**：
   - 提供了时间相关的函数，如 `time()`、`localtime()`、`gmtime()`、`strftime()` 等。

7. **浮点数处理库（float.h）**：
   - 定义了浮点数处理相关的常量和限制，如 `FLT_MAX`、`DBL_MAX`、`FLT_EPSILON` 等。

8. **断言库（assert.h）**：
   - 提供了 `assert()` 宏，用于调试时检查程序中的条件是否满足。

9. **复杂数学库（complex.h）**：
   - 提供了复数相关的数学函数。

10. **信号处理库（signal.h）**：
    - 提供了信号处理相关的函数，如 `signal()`、`raise()` 等。

11. **本地化库（locale.h）**：
    - 提供了本地化相关的函数，如 `setlocale()` 等。

12. **宽字符库（wchar.h）**：
    - 提供了宽字符和多字节字符之间的转换函数，如 `mbtowc()`、`wctomb()` 等。

13. **错误处理库（errno.h）**：
    - 定义了错误码，用于处理函数调用失败时的错误信息。

14. **目录操作库（dirent.h）**：
    - 提供了目录操作相关的函数，如 `opendir()`、`readdir()`、`closedir()` 等。

15. **正则表达式库（regex.h）**：
    - 提供了正则表达式相关的函数，如 `regcomp()`、`regexec()`、`regerror()`、`regfree()` 等。

这些库函数是C语言编程的基础，它们帮助程序员处理各种常见的编程问题，提高编程效率。在使用这些库函数时，通常需要在程序的开头包含相应的头文件。
</details>

### include<stdio.h>

<details>
<summary>点击查看scanf( )函数的定义及用法 </summary>
`scanf` 是 C 语言标准库中的一个函数，用于从标准输入（通常是键盘）读取格式化输入。它的原型定义在 `stdio.h` 头文件中，如下所示：

```c
int scanf(const char *format, ...);
```

`scanf` 函数的返回值是成功匹配并赋值的变量数量，如果遇到错误或读到文件末尾（EOF），则返回 EOF。

基本用法

`scanf` 的第一个参数是一个格式字符串，它指定了输入的预期格式，后续参数是指向变量的指针，用于存储输入的值。

1. 基本数据类型

- `%d`：读取一个十进制整数，并将其存储在 `int` 类型的变量中。
- `%ld`：读取一个十进制整数，并将其存储在 `long` 类型的变量中。
- `%c`：读取一个字符，并将其存储在 `char` 类型的变量中。
- `%s`：读取一个字符串，并将其存储在 `char` 类型的数组（字符串）中。
- `%f`：读取一个浮点数，并将其存储在 `float` 类型的变量中。
- `%lf`：读取一个浮点数，并将其存储在 `double` 类型的变量中。

2. 空格和匹配

- `scanf` 会跳过任何空白字符（空格、制表符、换行符）。
- `%*d`：匹配一个整数，但不存储它。
- `%*s`：匹配一个字符串，但不存储它。

3. 字面量匹配

- `%[abc]`：匹配任意字符集合中的字符。
- `%[^abc]`：匹配不在字符集合中的字符。
- `%[a-z]`：匹配任意小写字母。

4. 精度指定

- `%.2f`：读取浮点数时，只读取两位小数。

5. 宽度指定

- `%3d`：读取最多3位数的整数。
- `%3s`：读取最多3个字符的字符串。

注意事项

1. **地址操作符**：`scanf` 需要变量的地址作为参数，因此使用 `&` 操作符。
2. **字符串终止**：当使用 `%s` 读取字符串时，`scanf` 会在遇到空白字符时停止读取，并在字符串末尾自动添加 `\0`。
3. **错误处理**：`scanf` 不会检查变量的大小，如果输入的数据超出变量的存储能力，可能会导致缓冲区溢出。
4. **返回值**：`scanf` 返回成功赋值的变量数量，因此可以检查返回值以确认输入是否成功。
5. **安全性**：由于 `scanf` 可能导致缓冲区溢出，建议使用 `fgets` 和 `sscanf` 等更安全的函数来处理输入。

`scanf` 是一个强大的函数，但使用时需要小心，以避免常见的安全问题。

</summary>
<details>
<summary> 点击查看getchar( )函数的定义及用法 </summary>
  `getchar()` 是 C 语言标准库中的一个函数，它定义在 stdio.h头文件中。这个函数用于从标准输入流（通常是键盘）读取下一个可用的字符，并返回这个字符。如果到达输入流的末尾，它会返回一个特殊的值 `EOF`（End Of File），在 C 语言中通常定义为 `-1`。

函数原型
```c
int getchar(void);
```

功能
- `getchar()` 函数每次调用时，会从标准输入读取一个字符。
- 如果成功读取字符，它返回该字符（以 `int` 类型）。
- 如果遇到文件结束符（EOF），则返回 `EOF`。

注意事项
- `getchar()` 函数会读取并返回第一个可用的字符，包括空格、制表符和换行符。
- 如果你需要读取一行文本，可能需要使用循环来连续调用 `getchar()`，直到遇到换行符 `\n` 或 EOF。
- 在使用 `getchar()` 时，需要注意它不会自动忽略空白字符，这与 `scanf()` 函数的行为不同。
1. 读取单个字符

```c
    char ch;
    printf("Enter a single character: ");
    ch = getchar();  // 读取单个字符
    printf("You entered: %c\n", ch);

```

这个程序会读取用户输入的单个字符，并将其打印出来。

2. 读取一行输入直到遇到换行符

```c
#include stdio.h
#include string.h
int main() {
    char line[100];
    int i = 0;

    printf("Enter a line of text (end with Enter): ");
    while ((line[i] = getchar()) != '\n' && line[i] != EOF) {
        i++;
    }
    line[i] = '\0';  // 确保字符串以空字符结尾

    printf("You entered: %s\n", line);
    return 0;
}
```

这个程序会读取用户输入的一行文本，直到用户按下回车键（换行符）。

3. 读取字符直到遇到特定的字符

```c
    char ch, delimiter = '$';

    printf("Enter characters until you reach '%c': ", delimiter);
    while ((ch = getchar()) != delimiter && ch != EOF) {
        printf("You entered: %c\n", ch);
    }
```

这个程序会持续读取字符，直到用户输入特定的分隔符（在这个例子中是 `$`）。

4. 简单的字符回显

```c
    char ch;

    printf("Enter characters to echo them back: ");
    while ((ch = getchar()) != '\n' && ch != EOF) {
        putchar(ch);  // 使用 putchar 函数回显字符
    }
```

这个程序会回显用户输入的每个字符，直到遇到换行符。
</details>
<details>
<summary>点击查看putchat( )函数的定义及用法</summary>

`putchar` 是 C 语言标准库中的一个函数，用于向标准输出（通常是屏幕）输出一个字符。其定义如下：

```c
int putchar(int c);
```

这个函数接受一个 `int` 类型的参数 `c`，这个参数代表要输出的字符的 ASCII 值。`putchar` 函数返回输出的字符，如果发生错误，则返回 `EOF`（一个负数，通常定义为 -1）。

场景示例

1. **输出单个字符**

```c
int main() {
    putchar('A'); // 输出大写字母 A
    return 0;
}
```

在这个例子中，`putchar` 被用来输出单个字符 'A'。

2. **输出字符串**

```c
int main() {
    char str[] = "Hello, World!";
    for (int i = 0; str[i] != '\0'; ++i) {
        putchar(str[i]);
    }
    return 0;
}
```

在这个例子中，`putchar` 被用来逐个输出字符串中的字符。循环直到遇到字符串的结束符 `\0`。

3. **输出数字字符**

```c
int main() {
    int num = 123;
    while (num > 0) {
        putchar(num % 10 + '0'); // 将数字转换为字符
        num /= 10;
    }
    return 0;
}
```

在这个例子中，`putchar` 被用来输出一个整数的每一位数字。通过取模操作 `%` 得到最低位的数字，并将其转换为字符。

4. **错误处理**

```c
int main() {
    int result = putchar('B');
    if (result == EOF) {
        perror("putchar failed");
    }
    return 0;
}
```

在这个例子中，我们检查了 `putchar` 的返回值。如果返回 `EOF`，则表示输出失败，我们使用 `perror` 函数打印错误信息。

5. **输出换行符**

```c
int main() {
    putchar('\n'); // 输出一个换行符
    return 0;
}
```

在这个例子中，`putchar` 被用来输出一个换行符，这会导致光标移动到下一行的开头。

6. **输出多个字符**

```c
int main() {
    putchar('H'); // 输出 H
    putchar('i'); // 输出 i
    putchar('!'); // 输出 !
    return 0;
}
```

在这个例子中，`putchar` 被连续调用三次，每次输出一个字符，组合起来就是 "Hi!"。

`putchar` 是一个简单但非常有用的函数，它允许程序直接向标准输出流发送单个字符。在实际编程中，`putchar` 常用于字符的逐个输出，尤其是在需要精确控制输出格式时。
</details>
	putchar() : 一次接受一个字符，把它变成int，作用：向标准输出写一个字符
	返回值：写了几个字符
		正常：return 1
		异常：EOF(-1) EOF为宏，其值为-1


	getchar() : 返回值是int， 返回读到的那个字符
	返回EOF：输入结束
		结束输入的方法：win : Ctrl + Z; linux : Ctrl + D ; 而输入Ctrl + C:强制结束程序
			按Ctrl + D，shell看到之后填一个EOF or -1 orothers， 给到程序，程序检测到EOF，结束；而输入Ctrl + C，shell直接关闭程序
	输入回车才 ： 原因是shell（行编辑：按shell前东西都在shell里面，在按enter后东西才从shell送到程序那里）
### include<string.h>

1. **字符串拷贝**：`strcpy(s1, s2)` 将字符串 `s2` 拷贝到 `s1` 中。
   ```c
   char s1[20], s2[] = "Hello";
   strcpy(s1, s2);
   ```

2. **字符串连接**：`strcat(s1, s2)` 将字符串 `s2` 连接到 `s1` 的末尾。
   ```c
   char s1[20] = "Hello, ";
   char s2[] = "World!";
   strcat(s1, s2);
   ```

3. **字符串比较**：`strcmp(s1, s2)` 比较两个字符串，如果 `s1` 和 `s2` 相同返回0，否则返回非0值。
   ```c
   char s1[] = "Hello";
   char s2[] = "Hello";
   if (strcmp(s1, s2) == 0) {
       printf("The strings are identical.\n");
   }
   ```

4. **字符串长度**：`strlen(s)` 返回字符串 `s` 的长度，不包括结尾'\0'
	函数原型：`size_t strlen(const char *s)`
	内部const指针的意义：保证该函数不会修改那个字符串
   ```c
   char s[] = "Hello";
   printf("The length of the string is: %lu\n", strlen(s)); // output:5 
   printf("The sizeof the string is: %lu\n", sizeof(s));  //output:6 
   ```

5. **字符串搜索**：`strchr(s, c)` 在字符串 `s` 中查找字符 `c` 的第一次出现。
   ```c
   char s[] = "Hello";
   char *c = strchr(s, 'l');
   if (c) {
       printf("The character 'l' is found in the string.\n");
   }
   ```

6. **字符串分割**：`strtok(s1, s2)` 将字符串 `s1` 根据 `s2` 中的分隔符分割成多个子串。
   ```c
   char s[] = "Hello, World!";
   char *token;
   // 使用strtok之前需要先调用一次，传入字符串
   token = strtok(s, " ");
   while (token != NULL) {
       printf("%s\n", token);
       token = strtok(NULL, " ");
   }
   ```

7. **字符串复制**：`strncpy(s1, s2, n)` 将字符串 `s2` 的前 `n` 个字符拷贝到 `s1` 中。
   ```c
   char s1[20], s2[] = "Hello";
   strncpy(s1, s2, 3);
   ```

8. **字符串比较（限定长度）**：`strncmp(s1, s2, n)` 比较两个字符串的前 `n` 个字符。
   ```c
   char s1[] = "Hello";
   char s2[] = "Hello, World!";
   if (strncmp(s1, s2, 5) == 0) {
       printf("The strings are identical up to 5 characters.\n");
   }
   ```

9. **字符串格式化**：`sprintf(s, format, ...)` 将格式化的数据写入字符串 `s` 中。
   ```c
   char s[100];
   sprintf(s, "The value is: %d", 10);
   ```

10. **字符串反转**：虽然标准库中没有直接的函数，但可以通过循环实现。
    ```c
    void reverse(char s[]) {
        int i, j;
        char c;
        for (i = 0, j = strlen(s) - 1; i 》 j; i++, j--) {
            c = s[i];
            s[i] = s[j];
            s[j] = c;
        }
    }
    ```


函数多返回值
案例：复数加、乘
python：i用的是j；C：未给出i
1. 返回指针
	返回结构体
2. 全局变量
	定义：不涉及数据传递，而是数据共享
	初始化：不初始化则默认是0
	局部变量：定义内部，形参；出了定义他的语句块就没了
	全局变量：不在大括号里面的，不在函数内部定义的
	易错：内部重复定义局部变量
	同名？
	同名的话内部调用的先后顺序？
	使用：将值传给全局变量
	两次赋值：调用乘积以后和的结果被冲掉了
	范围：从定义到源文件结束（其实不对，但是考试认为对）
	多文件：1.c 最后定义的全局变量在2.c也能用
	慎重使用：形成了函数的<font color="#ff0000">多入口</font>，不知道哪个函数改变了它
	静态存储
	动态存储
	
函数声明：变量就带上含义，能看懂
函数设计：写之前把所有东西都规定好

静态局部变量
	== 全局变量
	调用之后，变量存的是这一次调用的返回值
```c
......
{
	static int a = 1;
	
}
```
<font color="#ff0000">再看书！！！没会</font>
int == auto int

全局变量、静态变量：不初始化都是0





# Chap7_Array

## C99中关于数组的规定
1. **变长数组（Variable Length Array, VLA）**：
	C99引入了变长数组的概念，允许数组的大小在运行时确定。这意味着数组的大小可以是变量的值，而不仅仅是编译时常量。例如：
   ```c
   int n = 10;
   int arr[n]; // 合法的变长数组
   ```
	
	可变长度数组定义时不能初始化，这是因为VLA的大小是在运行时确定的，而数组初始化需要在编译时知道数组的大小和元素的值。
	例如，以下代码是非法的，因为尝试在声明VLA时初始化它：

	```c
int size = 10;
int vla[size] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // 错误：不能初始化VLA
```

	但是，你可以在声明VLA之后立即使用循环或其他方法来初始化它。例如：

	```c
int size = 10;
int vla[size];
for (int i = 0; i < size; ++i) {
    vla[i] = i + 1;
}
```

	如果你需要在编译时就初始化数组，那么你可以使用静态数组或者在C99标准中使用复合字面量来初始化一个具有固定大小的数组。例如：

	```c
int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
```

	这里，`arr` 是一个具有固定大小的数组，可以在声明时初始化。

2. **零长度数组**：
   C99允许声明大小为零的数组，这在某些情况下非常有用，比如作为结构体的最后一个成员，以实现大小可变的数组。例如：
   ```c
   struct {
       int len;
       int data[];
   } dynamicArray;
   ```

3. **复合字面量（Compound Literals）**：
   C99引入了复合字面量的概念，允许在声明数组的同时初始化它，而不需要先声明数组的大小。例如：
   ```c
   int arr[] = {1, 2, 3, 4, 5};
   ```

4. **多维数组的声明**：
   C99允许更灵活地声明多维数组。例如：
   ```c
   int arr[10][5]; // 声明一个10x5的二维数组
   ```

5. **数组作为函数参数**：
   在C99中，数组作为函数参数时，可以省略数组的大小，编译器会将其视为指针。例如：
   ```c
   void printArray(int arr[], int size) {
       for (int i = 0; i < size; i++) {
           printf("%d ", arr[i]);
       }
       printf("\n");
   }
   ```

6. **数组的内存对齐**：
   C99标准规定了数组元素的内存对齐规则，以提高内存访问的效率。

7. **数组的初始化**：
   C99提供了更灵活的数组初始化方式，包括指定初始化和默认初始化。例如：
   ```c
   int arr[5] = {1, 2, 3}; // 初始化前三个元素，其余元素默认为0
   ```

变长数组在某些编译器中可能会有性能和内存使用上的考虑，因为它们可能需要在堆上动态分配内存。

## 一维数组
### 定义和引用
- 数组长度必须是整型常量表达式，即在定义时(编译时）确定；
	通俗讲，就是必须得是一个数字，不能放变量，即使那个变量有值也不行。
	即：
```c
//situation 1: ERROR
int n = 5;
int arr[n];

//situation 2: ERROR
int n;
scanf("%d", &n);
int arr[n];

//situation 3: right
int arr[10];
```
- 引用时只能引用单个值，不能一次引用整个数组。引用：其实就是*访问和操作*那个东西
	例子：` str[1] `

<details>
<summary> 点击展开引用 by Kimi </summary>
1. **变量名**：变量名是变量的标识符，用于在代码中引用变量。例如，如果你声明了一个整型变量 `int a;`，那么 `a` 就是这个变量的引用。

2. **地址引用**：在C语言中，可以通过指针来引用变量的内存地址。例如，如果你有一个指针 `int *ptr;` 并且你让它指向一个变量 `int a;`，那么 `ptr` 就是对 `a` 地址的引用。你可以通过 `*ptr` 来访问 `a` 的值。

3. **数组引用**：在数组中，可以通过索引来引用数组中的元素。例如，对于数组 `int arr[10];`，`arr[0]` 就是对数组第一个元素的引用。

4. **函数参数**：在函数调用时，可以通过参数来引用传递给函数的变量。例如，如果有一个函数 `void func(int x);`，当你调用 `func(a);` 时，`x` 就是对 `a` 的引用。

5. **结构体和联合体成员**：在结构体或联合体中，可以通过点操作符（`.`）或箭头操作符（`->`）来引用成员变量。例如，对于结构体 `struct MyStruct { int member; };` 的一个实例 `MyStruct myStruct;`，`myStruct.member` 就是对 `member` 成员的引用。
在C语言中，变量的引用通常涉及到变量名、指针、数组索引、函数参数等概念。这些引用方式允许程序员在程序的不同部分访问和操作变量。

</details>

- 数组下标越界：
	要求：不可越界访问
	越界访问，随意赋值

- 在内存中的存放
	与前后数据：见下神奇的try：不一定
	内部：index从小到大地址依次增大。从下到上排
	
### 初始化
- C语言规定只能对静态存储的数组初始化，但是课本允许·对动态数组+静态数组初始化
	eg：
```c
static int arr[5] = {1, 2, 3, 4, 5}
```
- 不初始化：
	静态数组``` static arr[5] ```：不初始化则全是0
	动态数组``` arr[5] ```：不初始化则随机数
- 部分初始化：
	初始化前几个，后面没有初始化的元素默认赋值为0
- 全部元素都赋值则可以省略数组长度（不建议）
神奇的try：
```c
//按照书上的标准，这个定义方式是错的，但是不带了改代码了......
#include<stdio.h>
int main()
{
    int a = 4;
    int arr[a];
    for(int i = 0; i < a; i++){
        arr[i] = i;
    }
    int b = 3;
    printf("%p\n", &a); printf("%p\n", &b); printf("%p\n", &arr);  //打印三个的地址
    printf("%p\n",&arr[0]); printf("%p\n",&arr[3]); printf("%p\n",&arr[4]); printf("%p\n",&arr[7]); //越界访问，且发现&arr[7] ==&a
    printf("%d\n",*&arr[7]);
    printf("%d\n",*&a);  //发现上面那个之后试试a和arr[7]是什么，发现arr[7]被赋值为a的值4
    printf("%d\n",arr[9]); printf("%d\n",arr[10]); //越界访问，随意赋值
    int try[5] = {1, 2};
    printf("%d\n", try[3]); //初始化部分元素，后面的自动赋值0
    return 0;
}
/*
输出：
a's ptr:0x7ffc2289afe4  b's ptr:0x7ffc2289afe8  arr's ptr0x7ffc2289afd0  arr[0]'s ptr:0x7ffc2289afd0  arr[3]'s ptr:0x7ffc2289afdc 
arr[4]'s ptr:0x7ffc2289afe0  arr[7]'s ptr:0x7ffc2289afec  
arr[7]:4  *&a:4
arr[9]:0  arr[10]:579448784
try[3]:0
```


### 输入固定长度
```c
int str[100];
int k;
printf("Enter your string:"); //输入提示
k = 0;
while((str[k] = getchar() != '\n'){ //用getchar逐个获取字符，不到'\n'不停
	k++;  //统计字符数量
}
str[k] = '\0'; //输入结束符'\0'
```
判断回文：if != break；flag = 1;  最后if(!flag) printf("yes")

### 示例
- 用数组计算斐波那契数列，每行打印5个数字，最后一行不满5个也要换行
```c
# include <stdio.h>
# define MAXN 46                    /* 定义符号常量MAXN */
int main(void)
{
    int i, n;
    int fib[MAXN] = {1, 1};         /* 初始化前两个 */
    printf ("Enter n: ");    
    scanf ("%d", &n);
    if(n >= 1 && n <= 46 ){
        for(i = 2; i < n; i++){  
            fib[i] = fib[i - 1] + fib[i - 2];
        }  
        /* 学学人家怎么输出：*/
        for(i = 0; i < n; i++){
            printf("%6d", fib[i]);
            if((i + 1) % 5 == 0){   /* 每5个换行：循环变量i+1是5的倍数；注意细节i+1 */
                printf("\n");
            }  
        }
        if(n % 5 != 0){             /* 最后不满5个换行：数学转化：最后一行和总数mod5同余 */ /* 这只能学了 */
            printf("\n");
        }
    }else{
        printf("Invalid Value.\n"); 
    }
    return 0;
}
```

- 选择法排序
	My program:
	![[sort.c]]
	1. 一开始错是因为：没做到数组元素互换：我只将min变量的值与第k个元素交换，并没有改变数组中最后对应min的那个元素和第k个元素交换
	复杂了，没想到用下标代表元素，最后有遍历了一遍找下标，实现数组元素互换
	2. 还是不熟悉交换的过程，也没想清楚交换什么
	
	Answer program——the sorting and swapping process
```c
# include <stdio.h>
# define MAXN 10                    /* 宏 */
int main(void)
{
    /* 排序 */
    for(k = 0; k < n-1; k++){
        index = k;                      /* 直接用index记录最小值,因为后面交换需要用到index，替换我的min = arr[k] */
        for(i = k + 1; i < n; i++){     /* 寻找最小值所在下标 */
            if(a[i] < a[index]){
                index = i;  
            }
        }
        temp = a[index];                /* 交换 */
        a[index] = a[k];
        a[k] = temp;
    }
}
```


## 字符串
[[C Programming Note#数组与指针|点击查看数组与指针]]
`char arr[] = {'h', 'i'}` 不是字符串
`char arr[] = {'h', 'i', '\0'}` or `char arr[] = {'h', 'i', 0}` 是字符串
### 概念
有效长度：不包含‘\0' : 计算字符串长度不包括末尾0
结束符：'\0'
### 定义与初始化
定义：
`char str[]` or `char* str` 都可以用来定义数组，但是两个不一样！
如果要用指针：那么必须定义的时候初始化，否则将导致segmentation fault！
eg：
```c
char* str;
str[0] = 'h';
str[1] = 'i';
// 编译器输出:[1]    122420 segmentation fault (core dumped)  ./pta11_7
char* str2 = "hi";  // OK
```
定义方法
1. 放在一维数组中
```c
static char str[6] = {'h', 'a', 'p', 'p', 'y', '\0'}
```

2. 使用字符串常量
```c
static char str[6] = {"happy"}
```
or
```c
static char str[6] = "happy"
```
- 字符串常量：就是双引号括起来的一个字符串，
  两种定义方式：`char str[]` or `char* str`
	  `char* str` ：只读
	  `char str[]`：也是只读，不过在堆栈区会copy一份跟他一样的字符串，这个是可以修改的
  因此，定义字符串常量，
	  ![[d893bf4b529392ea8e1b9f686b3c3dd.jpg]]
- 字符串常量不能修改（但是不能写const……）
- 相同的字符串字面量初始化两个字符串不同名字的字符串常量，在一样的地址上（在代码段，是只读的）
- 
<details>
<summary> 点击展开/折叠：字符串常量by Kimi </summary>
在C语言中，`str1` 和 `str2` 的区别主要在于它们的存储位置和是否可以修改。

1. **`char* str1 = "hi";`**
   - 这里 `str1` 是一个指向字符的指针，它指向一个字符串字面量。字符串字面量存储在程序的只读数据段中，这意味着你不能修改 `str1` 指向的内容。尝试修改 `str1` 指向的字符串将导致未定义行为，通常是程序崩溃。
   - 例如，以下代码是不允许的：
     ```c
     str1[0] = 'H'; // 错误：不能修改字符串字面量
     ```

2. **`char str2[] = "hi";`**
   - 这里 `str2` 是一个字符数组，它在栈上分配了足够的空间来存储字符串 "hi" 及其结尾的空字符 `\0`。`str2` 存储的是数组的第一个元素的地址，这意味着你可以修改 `str2` 中的字符。
   - 例如，以下代码是允许的：
     ```c
     str2[0] = 'H'; // 正确：可以修改数组中的字符
     ```
     这将把数组 `str2` 的第一个元素从 `'h'` 改为 `'H'`。

- **字符串字面量（`str1`）**：字符串字面量存储在只读数据段中，这是C语言规范的一部分。编译器将字符串字面量放在只读内存区域，以防止程序修改它们。这样做的好处是可以节省内存，因为多个相同的字符串字面量可以共享同一块内存区域。

- **字符数组（`str2`）**：字符数组是在栈上分配的，它们的生命周期仅限于定义它们的函数或代码块。字符数组的内容可以被修改，因为它们不是存储在只读内存区域。

总结

- `str1` 是一个指向字符串字面量的指针，指向的内容是只读的。
- `str2` 是一个字符数组，其内容可以被修改。

这种设计允许程序在保持字符串字面量的不变性的同时，也能灵活地处理和修改字符串数据。

在C语言中，字符串常量是指存储在程序的只读数据段中的字符序列，它以空字符（`'\0'`）结尾。字符串常量通常用于存储文本数据，且在程序执行期间不能被修改。

在你提供的两个例子中：

- `char* str1 = "hi";`
  - 这里的 `"hi"` 是一个字符串常量，而 `str1` 是一个指向这个字符串常量的指针。

- `char str2[] = "hi";`
  - 这里的 `"hi"` 也是一个字符串常量，但 `str2` 是一个字符数组，它在栈上分配了空间，并且包含了字符串常量的内容。尽管 `str2` 本身不是一个字符串常量，它包含了字符串常量的内容，并且这些内容在数组中是可以被修改的。

字符串常量的例子

以下是一些字符串常量的例子：

```c
const char* literal1 = "Hello, World!";
const char* literal2 = "This is a string constant.";
```

在这些例子中，`"Hello, World!"` 和 `"This is a string constant."` 都是字符串常量。它们存储在只读内存区域，任何尝试修改这些字符串的行为都会导致未定义行为（通常是程序崩溃）。

为什么 `str2` 不是字符串常量

`str2` 不是字符串常量，因为它是一个字符数组，它包含了字符串常量的内容，但存储在栈上，并且其内容是可以被修改的。字符串常量本身是存储在只读内存区域的，而 `str2` 只是包含了这些内容的一个可修改的副本。

总结来说，字符串常量是指那些存储在只读内存区域的字符序列，它们在程序执行期间不能被修改。而 `str1` 和 `str2` 都是包含字符串常量内容的变量，但 `str1` 是一个指向字符串常量的指针，而 `str2` 是一个包含字符串常量内容的可修改的字符数组。


</details>

- 定义字符串长度 >= 字符串有效长度 + 1
	因为有结束符'\0'
	开大数组：只对前面的赋值，'\0'后面的与字符串无关，字符串到'\0'即结束，故不会影响字符串的处理
	例子见下面一个代码块
### 访问
- 可以用数组，可以用指针，多用指针
- 字符串的赋值

通常涉及'\0'，用它来控制
	例子：
```c
    auto char arr[80] = "happy";
    int i, k;
    //完全打印
    for(i = 0; i <= 80; i++){
        printf("%c\n", arr[i]);
    }
    //以下三种方式效果一样，第三种是倒序打印
    printf("%s\n", arr);            //first
    
    for(k = 0; k <= 80; k++){
        if(arr[k] != 0){
            printf("%c\n", arr[k]);
            continue;
        }
    }                              //second
    
    for(k = 80; k >= 0; k--){
        if(arr[k] != 0){
            printf("%c\n", arr[k]);
            continue;    
        }                          //third
    }
```

### 存储
#### 赋值
将……存入数组，再将后面一个字符赋值为'\0'
```c
char* str1 = "hi";
char* p;
p = str1;  //含义是：str2指向str1的那个字符串
```
#### 输入输出
用scanf
	基本概念：
		1. scanf读一个单词：到空格/tab/回车 为止，即见到那三个就停止读入了
		   eg：char str\[8]; scanf("%s", str); printf("%s", str); ----> input: 123 45678 ----> output: 123
		2. %ns  (n为一个整数)：这次输入最多输入那么多个值，其他的内容停在输入流中，等待下一个scanf，
		   这些scanf依然遵循上一条
例子：
```c
char str1[8];
char str2[8];
scanf("%3s", str1);
scanf("%s", str2);
printf("%s##%s", str1, str2);
/*
input 1234 56 --> output 123##4
input 12 345 --> output 12##345
input 12 34567789835374 --> *** stack smashing detected ***: terminated \ [1]    25177 IOT instruction (core dumped)  ./wk
input 123456 --> output 123##456
```
用特定字符控制，并将其再赋值为'\0'

用putchar(), getchar()
[[|点击查看putchar()]]
[[|点击查看getchar()]]
### 杂项
`char **a` : a是一个指针，指向另一个指针，那个指针指向一个字符串
`char *a[]` : 
	![[e470499432d50fbee287f1eff71643b.jpg]]
#### 程序参数
main函数
	原型：`int main(int argc, char const *argv[])`
	argv\[0] 命令
程序链接：
![[Pasted image 20241109184458.png]]

看看busybox

## 二维数组

### 定义和引用
- 多个类型相同的一维数组
- 行长度列长度分别是整形常量表达式，先行数后列数
- 在内存中的存放
	按行——列顺序存放：先0行，再1行……每行按列顺序存放
	从上到下：00,01,02,10,11,12,20,21,22……

### 初始化
- 分行赋值
	按顺序每行一个括号
	部分赋值
		括号在：内部也可像一维的一样只赋前面几个的值，空括号代表全0
		没or少括号：代表全0
- 顺序赋值
	全写出 or 部分写出，
- 如果完整赋值，可以省略行长度
![[Pasted image 20241107154007.png]]
### 矩阵的术语 
```c
for(i = 0; i < n; i++){
	for(j = 0; j < n; j ++){
		// 见下
		}
}
```
主对角线：``` if(i == j)```
上三角： ``` if(i <= j)```
下三角：``` if(i >= j)```
副对角：``` if(i + j == n - 1)```

遍历上三角：
```c
/*j的循环体：*/ j = i; j < n; j++
```


定义：同类型变量的集合
数组在内存中的存放方式：<font color="#ff0000">一维二维都看</font>
int arr\[n];
长度必须是常量，
突破：必须有一个值
数组定义后面再改变a的值，不影响前面
<font color="#245bdb">int arr[0] ?</font>
switch：case后面也必须是常量
int arr\[10]; 10个变量：arr【0】~ arr【9】
for i in range(0, 10) :表示arr中的10个数
内存分布：
	int 4byte，1byte == 8bit
	arr的地址
	一维：
		为存放数组在内存空间的首字节的地址
		指向首元素的指针
	11:15
	末尾：
作用：定义一堆变量
int a\[10] :只有定义时候使用
后面再使用a\[10]：越界
每次运行：操作系统分配内存
指针：C的精华
	地址，内存的关系，越界访问
	![[e331302a828edfdb3a25f9556a34638.jpg]]

静态数组
	不初始化则所有都是0
动态数组
	不初始化则所有都是随机数
	大部分编译器：初始化前面几个，后面也会初始化成0
	数组的长度的省略：arr【】
	
不用数组算fibonacci

用宏定义数组

学算法思想
    找到没找到，找到了数据放在哪
    eg：flag
    处理的细节
stdlib.h 里面min max 为函数名，所以别用它当变量名

读程序的功夫



# 指针
## 概念与定义
- Whether %p and %l %x have the same size and form, it depend on the IDE(64bit or 32bit)
- 取址符右边只能是变量`&(++i)`,`&(i + j)`均不合法
- 数组
```c
printf("%p", arr);
printf("%p", &arr);
printf("%p", &arr[0]);
//三个输出结果相同
printf("%d", *arr); //打印出第一个元素
```
基本定义
```c
int i;
int *p = &i;
int* p = &i;
```
理解：
	1. 没有int\*这个变量类型，理解成：\*p是一个int
	2. 理解：有一个整型变量i，p这个变量的值是变量i地址的变量，称p为指针变量
```c
int*p, q;
```
易错
	其中，q只是普通int变量

## 应用
### 指针与函数
#### 指针做参数
函数：仍然是参数的传递
变量作参数：将那个变量的值给到函数的形参，而函数结束后，形参消失，原来的变量仍然是原来的值
指针做参数：将那个变量的值给到函数的形参，这里，值是地址值，通过地址，可以在函数内部访问外面那个值

#### 函数多返回值
例子：
```c
#include<stdio.h>
void minmax(int arr[], int *min, int *max) 
/*
传入参数有讲究：要在定义的函数中对main函数输入/定义的数组进行处理，就必须得传入它，这是函数参数传递的基本内容;
传入指针变量，因为定义的函数内部要对main函数中的min，max变量进行处理，原理同上面;
**核心：要在函数内部对主函数的变量进行操作，则必须得把主函数中的那个变量or其地址传入函数**
*/
{
    int i, j;
    *min = arr[0];
    *max = arr[0];
    for(i = 0; i < 5; i++){
        if(arr[i] >= *max) *max = arr[i];
        if(arr[i] <= *min) *min = arr[i];
    }
    printf("min = %d\n", *min);
    printf("max = %d", *max);
}
int main()
{
    int min; int max;
    int arr[5] = {1,4,7,5,0};
    minmax(arr, &min, &max);
    return 0;
}
```
注：
	函数参数表中的数组是什么？
		答：指针。
		形式：`int a[]` `int *a` 都行
		~~其实，定义数组也可以 `int *a` , a可以当作数组~~：完全错误的说法：故划掉！
#### 函数返回状态
函数的return返回运算的状态，通过指针返回运算结果

### 数组与指针
![[ef30ed0352b6b6578ac351ccf2142a7.jpg]]

#### 用法
关于数组名：
 指针和数组的等价性：**数组名是指向数组首元素的指针**。例如：
   ```c
   int arr[10];
   int *ptr = arr; // ptr现在指向数组arr的第一个元素
   ```
 而，`int* arr = {1,2,3,4,5,6}` 是错误的！
	![[Pasted image 20241109104148.png]]
	initialization of ‘int \*’ from ‘int’ makes pointer from integer without a cast：试图将一个整数值赋给一个整型指针，而没有进行类型转换。
	excess elements in scalar initializer：尝试使用一个包含多个元素的初始化列表来初始化一个单一的标量值（即非聚合类型，如单个整数、浮点数、字符等），而不是一个聚合类型（如数组或结构体）。
	错因：
		数组名是一个指向首元素的指针，不是说数组名是一个指向整个数组的指针，也就是excess elements in scalar initializer，故不能用一个指针定义数组
	改正：
		见上序号1.
但是，这样是对的：用\*p++遍历
```c
    int arr[] = {1,2,3,4,5,6,-1};
    int* p = arr;
    while(*p != -1){
        printf("%d\n", *p++);
    }
```
再定义一个指针，等于数组名/首元素的地址，当p++，可以在数组中逐位移动，实现遍历
这样也是对的
```c
    int n, i;
    scanf("%d", &n);
    int* arr = (int* )malloc(n * sizeof(int));
    for(i = 0; i < n; i++) scanf("%d", &arr[i]);  //主要看这行，定义一个指针，指针可以用[]运算符
    for (i = 0; i < n; i++) printf("%d#", arr[i]);
    return 0;
```
#### 其他
1. 数组指针有时候可以混着用
   eg：
```c
   int a = 6; 
   int *p = &a;
   printf("%d", *p);
   printf("%d", p[0]);
   //最后两行一样
```
2. 数组变量是const类型指针:常量指针
   即：`int b[]` <=>`int* const b`
   故数组变量不能直接赋值, 即：
```c
int arr1[3] = {1,2,3};
int arr2;
arr2 = arr1;  //ERROR
```

### const与指针
1. 指针可以是const(指针不可修改：const在\*后面)：这个指针变量的值（地址）不能变了，不能再指向其他变量
  `int* const q = &i    //q is const`
  `q++   //ERROR`
  `i = 20    //OK`
2. 所指的是const(通过指针不可修改：const在\*前面)：表示不能通过这个指针去修改哪个变量，但是这个指针和那个变量都不是const都可以修改
   `const int *p = &i    `
   `i = 20; i++    //OK`
   `p++    //OK`
   `p = &j    //OK`
   `*p = 30    //ERROR`   
	用处：大的结构用const结构的指针
3. const数组
const int a\[] = {1,2,3,4,5,6} : 这里的const表示每个元素都是const int
	用处：防止函数对数组修改：`int func(const int arr[], int len)`

## 指针运算
指针加减数字
	int \*(p+1) 对，是加一个sizeof()
	int \*p+1 错！没有意义的
	可以++，--，+=，-=
	对数组：\*p <=>p\[0] ; \*(p + 2) <=>p\[2]
	只有指向连续空间的指针 + 1才有意义：就是加之后的指针的\*有意义
两个指针相减
	结果：地址差/sizeof：中间能放几个这样的数据
应用
	\*p++ : 取出原本这个位置的值再把p+1
	[[C Programming Note#有关数组名|点击查看示例]]
指针比较
	<, <=, >, >=, =, != 
	比较地址大小
	数组中元素地址*线性递增*

## NULL与0地址
![[4cae174e0d2419d01df27f9485796fa.jpg]]

## 动态内存分配
C99中的代替方法：可变长度数组
C89中：malloc函数：在<stdlib.h>里面
例子：`int* a = malloc(n * sizeof(int))`
malloc() : 
	函数原型：
		`void* malloc(size_t size);`
		`void free(void *ptr);`
		free() and malloc() is 绑定使用的
	参数：内存大小; 
	返回值：void* ：一个指针，指向一块内存，单位为字节
	之后需要强制类型转换 `(int*)malloc(n * sizeof(int))`
	之后将malloc产生的那个指针当数组来用即可
	之后要free(a)  //a 是那个指针
		必须得是malloc申请来的内存才能被free，其他不行
		好习惯：定义指针先赋值0，最后在free(0)
		记住要free；
		合理设计程序结构以找到合适地方进行free
	如果没有内存了：
		返回0 orNULL
	例子：
```c
    int n, i;
    scanf("%d", &n);
    int* arr = (int* )malloc(n * sizeof(int));
    for(i = 0; i < n; i++) scanf("%d", &arr[i]);
    for (i = 0; i < n; i++) printf("%d#", arr[i]);
    free(arr);
    return 0;
```

## 杂项
1. 指针一定要现初始化！
2. 指针类型转换
	原理：换一种视角去看那些内存空间
	普通指针
		事实上，指针的大小都是一样的，可以进行强制类型转换
		理解：用内存格格来看：原来这堆格格代表A类型的数据，强制类型转换后代表B类型的数据，按照数据存储的规则进行“翻译”即可
		例子：
   <details>
   <summary>点击查看不同类型指针的相互赋值by Kimi</summary>
   在C语言中，`int` 类型和 `char` 类型的指针可以相互赋值，因为它们通常具有相同的大小（在大多数平台上，`char` 是1字节，`int` 是4字节，但指针的大小是固定的，通常是4字节或8字节，取决于系统架构）。然而，这种赋值通常是不安全的，因为 `int` 和 `char` 指针指向的数据大小不同，解引用这些指针可能会导致未定义行为。

以下是一些示例和说明：

示例1：将 `int*` 赋值给 `char*`
```c

    int i = 10;
    int* intPtr = &i;
    char* charPtr = (char*)intPtr; // 将int*转换为char*

    // 打印charPtr指向的值
    printf("%d\n", *charPtr); // 打印i的最低字节

```
在这个例子中，我们将 `int` 类型的指针转换为 `char` 类型的指针，并打印出指向的值。这里打印的是 `int` 值的最低字节，因为 `char` 类型是1字节的。

示例2：将 `char*` 赋值给 `int*`
```c

    char chars[4] = {'a', 'b', 'c', 'd'};
    char* charPtr = chars;
    int* intPtr = (int*)charPtr; // 将char*转换为int*

    // 打印intPtr指向的值
    printf("%c\n", *intPtr); // 打印chars数组的前4个字节作为一个整数

```
在这个例子中，我们将 `char` 类型的指针转换为 `int` 类型的指针，并打印出指向的值。这里打印的是 `char` 数组的前4个字节作为一个整数的ASCII值。

注意事项
虽然这些赋值在技术上是可能的，但它们可能会导致未定义行为，特别是当你尝试解引用这些指针并访问它们指向的数据时。这是因为 `int` 和 `char` 类型的数据在内存中的表示和对齐方式可能不同。

- **对齐问题**：许多系统要求 `int` 类型的数据必须在4字节边界上对齐，而 `char` 类型的数据没有这样的要求。将 `char*` 赋值给 `int*` 可能会导致对齐问题，从而导致程序崩溃或数据损坏。
- **数据解释**：将 `int*` 赋值给 `char*` 或反之，可能会导致数据解释错误，因为 `int` 和 `char` 类型的数据在内存中的布局不同。

因此，除非完全清楚这样做的后果，否则应避免将 `int` 和 `char` 类型的指针相互赋值。在实际编程中，最好使用相同类型的指针来操作相同类型的数据。
</details>
	涉及void\*指针
		作用：将那段内存空间（格格）换了一种视角去看
		![[78ec12a65dcdd569555939f4546e797.jpg]]
# 编译预处理和宏
## 编译预处理
”\#“：编译预处理指令
例子：`#include<stdio.h>`
## 宏
`#define`：定义一个宏（是一个符号）
范例程序见下
### 要点
- 语法：没有等号，没有分号（因为不是一条C语句，其他语言都是用\#编译预处理）
- 值：可以是任何东西，可以空格、标点等：名字再空格后面所有东西
- 没有值的宏：
	
- 其他：
	![[4caba12cd1296d72bfdb432c8936489.jpg]]
- 位置：
	普通：源代码文件的顶部，或者放在头文件中
<details>
<summary> 点击查看宏的所有定义位置</summary>
在C或C++中，定义宏（Macro）通常有两种方式：

1. **预处理器指令**：
   - 宏定义通常写在源代码文件的顶部，或者放在头文件中。它们使用预处理器指令`#define`来定义。
   - 例如，在源文件或头文件中定义一个宏：
     ```c
     #define MY_MACRO 123
     ```
   - 这种方式定义的宏在编译器进行预处理阶段之前就会被处理。

2. **命令行参数**：
   - 你也可以在编译时通过命令行参数定义宏。这在编译器（如GCC）的命令行参数中使用`-D`选项来实现。
   - 例如，在GCC中定义一个宏：
     ```zsh
     gcc -DMY_MACRO=123 source_file.c
     ```
   - 这种方式定义的宏会在预处理阶段被识别和替换。

3. **配置文件**：
   - 在某些项目中，宏定义可能被放在一个专门的配置文件中，然后通过包含该文件来使用这些宏定义。

4. **Makefile**：
   - 在使用Makefile构建项目时，可以在Makefile中定义宏，并通过`-D`选项传递给编译器。

5. **构建系统**：
   - 在使用现代构建系统（如CMake或Bazel）时，宏定义可以在构建脚本中设置，并在编译时传递给编译器。

宏定义的位置取决于你的项目结构和个人偏好。通常，如果宏是项目中多个文件共享的，最好将它们定义在头文件中。如果宏是特定于单个文件的，可以直接在该文件中定义。如果宏的值需要在不同的构建之间改变，那么在命令行或构建系统中定义宏可能更灵活。

当然，让我们更详细地探讨在C/C++项目中定义宏的第2、4和5点：

2. 命令行参数

在编译时，你可以通过编译器的命令行参数来定义宏。这通常通过`-D`选项来实现，后面跟着宏的名称和可选的值。这种方法特别适用于：

- **编译时配置**：根据不同的编译选项启用或禁用特定的代码段。
- **环境变量**：在不同的开发环境或部署环境中使用不同的宏值。

**示例**：

```bash
gcc -DDEBUG -DMAX_THREADS=4 -o my_program my_program.c
```

在这个例子中，`DEBUG`和`MAX_THREADS`被定义为宏，`DEBUG`没有指定值（通常用来启用调试代码），而`MAX_THREADS`被赋予了值`4`。

4. Makefile

在Makefile中定义宏可以在构建过程中提供灵活性，特别是当你需要根据不同的目标或平台调整编译选项时。你可以在Makefile中设置宏，然后在编译命令中使用这些宏。

**示例**：

```makefile
CFLAGS += -DUSE_FEATURE -DVERSION='"1.2.3"'

all:
    gcc $(CFLAGS) -o my_program my_program.c
```

在这个Makefile中，`CFLAGS`变量被用来添加编译器标志，包括定义宏`USE_FEATURE`和`VERSION`。当你运行`make`命令时，这些宏会被传递给GCC编译器。

5. 构建系统

现代构建系统如CMake提供了强大的宏和变量管理功能，允许你在构建过程中定义和使用宏。这些宏可以用于控制编译选项、源文件包含、依赖关系等。

**示例**：

```cmake
# CMakeLists.txt

# 定义一个宏
add_definitions(-DENABLE_DEBUG)

# 设置一个变量，可以作为宏的值
set(MY_VERSION "1.2.3")

# 将变量转换为宏
add_definitions(-DVERSION=${MY_VERSION})

# 指定C++标准
set(CMAKE_CXX_STANDARD 11)

# 构建目标
add_executable(my_program my_program.cpp)
```

在这个CMake配置文件中，我们使用`add_definitions`来定义宏和添加编译器标志。`set`命令用于设置变量，这些变量可以被用作宏的值。`add_executable`定义了一个可执行文件目标，它将使用前面定义的宏和设置。

使用构建系统定义宏的好处包括：

- **跨平台支持**：构建系统通常提供了跨平台的构建配置。
- **依赖管理**：自动处理源文件和库的依赖关系。
- **可重用性**：构建脚本可以在多个项目中重用，只需少量修改。

这些方法提供了在不同层面上控制宏定义的灵活性，使得项目构建更加模块化和可配置。

</details>

- 注释：依然作为C语言注释

范例程序：
```c
#include<stdio.h>
#define PI 3.14
#define PI2 2 * PI  //不能写成2PI，因为不是合法的标识符 //一个宏中包含另一个宏
#define FORMAT "%f\n" //宏的值可以是任何东西
#define PRT printf("%f\n", PI); \
			printf(FORMAT, PI2 * 3)  //上面那一行"\"后面不能有任何东西空格、注释啥也不行 FORMAT文本替换，多行，第一行得有分号，因为被替换处需要分号
int main()
{
PRT;
return 0;
}
/*
也可以这样：
#define PRT printf("%f\n", PI); \
			printf(FORMAT, PI2 * 3);
int main()
{
PRT
return 0;
}
注意分号
*/
```

- 原理_文本替换：编译之前，编译预处理程序（cpp）把文件中所有宏的名字换成值
	gcc查看编译预处理过程中的文件
```zsh
gcc -g try.c -o try --save-temps
```
```zsh
ls -l
```
```zsh
tail try.i
```

![[Pasted image 20241031001051.png]]

<details>
<summary>
点击查看.c，.i， .o，.s 分别是什么 </summary>
这些文件扩展名代表了C/C++编程和编译过程中的不同阶段和类型的文件：

1. **.c**：
   - 这是C语言源代码文件的扩展名。它包含了用C语言编写的程序代码。例如，`main.c`就是一个C语言源文件。

2. **.i**：
   - 这是预处理后的源代码文件的扩展名。当你使用编译器的`-E`选项时，它会生成一个包含了预处理指令（如宏展开、条件编译指令、头文件包含等）后的文件。这个文件通常用于调试预处理阶段。

3. **.o**：
   - 这是目标文件（Object file）的扩展名。目标文件是编译器编译源代码后生成的中间文件，包含了源代码对应的机器码，但还没有进行链接。目标文件可以被链接器用来生成最终的可执行文件。

4. **.s**：
   - 这是汇编代码文件的扩展名。当你使用编译器的`-S`选项时，它会生成一个包含了源代码对应的汇编语言代码的文件。这个文件可以被汇编器进一步转换成目标文件。

5. **.a**：
   - 这是静态库文件的扩展名。静态库是一组目标文件的集合，它们被打包在一起，可以在编译时被链接到程序中。静态库通常用于共享代码或资源，而不需要在运行时动态加载。

6. **.so**：
   - 这是共享库文件（在Linux系统中）的扩展名。共享库是一种特殊的库，它们在运行时被动态加载和链接到程序中。这允许多个程序共享同一份库代码，节省内存并减少磁盘空间。

7. **.exe**：
   - 这是可执行文件的扩展名，在Windows系统中使用。可执行文件是编译后的程序，可以直接在操作系统中运行。

8. **a.out**：
   - 这是一个传统的可执行文件的名称，在Unix和类Unix系统中使用。在早期的Unix系统中，编译器默认生成的可执行文件被命名为`a.out`。尽管现代编译器允许你指定可执行文件的名称，但`a.out`仍然被用作默认名称，尤其是在某些特定的编译环境或教学示例中。

这些文件类型和扩展名是C/C++编程和编译过程中的基本组成部分，了解它们有助于更好地理解程序的构建和运行过程。
</details>



![[Pasted image 20241031093513.png]]