verilog

vivado

模拟信号 通过ADC 转换为数字信号

## 信号的采集和量化

- 简单: 二值量化: 有阈值, 高于阈值为1, 低于为0, 阈值附近有空洞(threshold region), 
    - 信号在中间则随机定义是0/1
    - 输入与输出的1/0阈值不同: 原因为信号传输中有干扰, 输入需要有容错, 故范围大
    - why binary? : 两个状态的器件多, 硬件资源消耗少

K/M/G/T
## 二进制运算
### 术语
carry in: 进到这里的位, carry: 这位的进位

MSB: 最高有效位 LSB: 最低有效位

borrow in: 别的位向我借的位, borrow

"基"(线代那个"基"): 单个位上最多放的数的个数~进制

### 计算
#### 加减法
#### 进制转换

!!! success "小数"

    小数即负指数次幂

**n -> 10**: 位值原理

**10 -> 2**:

- 法一: 一次次减最大的2的幂
- 法二: 整数 + 小数: 
    - 整数: 除2取余, 逆向读取; 
    - 小数: 乘2取整, 小数继续, 正向读取;

    !!! info

        - 整数: 直到商 = 0, 一定可以准确表示
        - 小数: 可能无穷/循环 -> 人十进制和计算机二进制间误差

        !!! info "想想原因"

            基之间的相互转换, 是一个不定方程

        原理: 


**8/16 -> 2**

restate: 重声明, 一位变3/4位, 不足的往前面填充0

**2 -> 8/16**

regroup: 重组, 从小数点开始往左/右数, 3/4位变1位

- 整数部分最左边: 011 -> 11, 001 -> 1
- 小数部分最右边: 110 -> 11, 100 -> 1

**8 <-> 16**

引入二进制为中间桥梁

## 信息编码

非数字 -> 数字, 例如颜色的二进制编码

最少的位数: 有M个需要编码的元素, 用n位二进制表示, 满足如下等式:

$$2^{n - 1} \lt M \lt 2^n$$

即对数再向上取整

这样一来对0~9的编码有很多种编码方式, 有如下有价值编码方式

- BCD码(8, 4, 2, 1码)

    !!! info

        8/4/2/1代表每一位的权重

        编码不一定有权重, 例如颜色编码

计算

\+ 6 补偿, 当出现非法码时

可以直接按照十进制加
- 8, 4, -2, -1码

    - 补码直接取反即可
- 余3码

    - 补码直接取反即可

- 格雷码

    - 抗干扰

- 独热码

- 7位ASCII

    - 大小写: 最低四位相同, 高三位差一位, 反转第五位
    - DEL: 因为之前纸带

### 错误检测和纠正

原理: 信道编码: 错误的检测和纠正, 加入冗余信息, 加入校验位

奇odd/偶even校验: 头上(MSB)/尾上(LSB)加入一个0/1, 目的是使得1的个数位奇/偶数


编码包括信源编码 + 信道编码(错误的检测和纠正, 加入冗余信息, 加入校验位)

- 格雷码gray code

    - 相邻俩数有一个位反转, 
    - "二进制反射格雷码": 以中间对称的两个数所有位都反
    - "头"在变化
    - 算法: 先写出BCD码, 最高位与BCD一样, 后面的位(从前往后)第n位为BCD码第n和n - 1 位的二进制加法的最低位

编码盘:

- 出现skew(信号畸变和干扰): 在分割线上所有编码均有可能
    - 用格雷码: 两个间只变一位: 能量消耗低/有两位一样, 误差小

    